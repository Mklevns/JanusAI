"""
Physics Data Generators
=======================

Provides abstract and concrete classes for generating physically accurate
time-series or observational data for various physics systems.
These generators are used to create datasets for physics discovery tasks.
"""

import numpy as np
from typing import Dict, Tuple, Optional, Any
from abc import ABC, abstractmethod
import scipy.integrate as integrate


class PhysicsDataGeneratorBase(ABC):
    """
    Abstract base class for physics data generators.

    Subclasses must implement:
    - `get_default_param_ranges`: Defines the ranges for physical parameters.
    - `dynamics`: Defines the differential equations governing the system.
    - `sample_initial_conditions`: Defines how to sample initial states for simulations.
    - `compute_observables`: Defines which quantities are observable from the state.
    """

    def __init__(self,
                 dt: float = 0.01,
                 t_max: float = 10.0,
                 param_ranges: Optional[Dict[str, Tuple[float, float]]] = None):
        """
        Initializes the base physics data generator.

        Args:
            dt: Time step for numerical integration (e.g., in `odeint`).
            t_max: Maximum simulation time for a single trajectory.
            param_ranges: Optional dictionary to override default parameter ranges.
        """
        self.dt = dt
        self.t_max = t_max
        # Use provided param_ranges or call abstract method for defaults
        self.param_ranges = param_ranges if param_ranges is not None else self.get_default_param_ranges()
        
    @abstractmethod
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        """
        Returns a dictionary of default parameter names mapped to their
        (min, max) ranges for random sampling.
        """
        pass
    
    @abstractmethod
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        """
        Defines the system dynamics (rate of change of state variables).
        This method is used by `scipy.integrate.odeint`.

        Args:
            state: Current state vector of the system.
            t: Current time.
            params: Dictionary of physical parameters for the current simulation.

        Returns:
            NumPy array representing the derivatives of the state variables.
        """
        pass
    
    @abstractmethod
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """
        Computes observable quantities from the integrated state trajectory.
        This transforms the raw state variables (e.g., [x, v]) into the variables
        the agent will observe (e.g., [x, v, energy]).

        Args:
            trajectory: The full state trajectory generated by `odeint` (time_steps, state_dim).
            params: Dictionary of physical parameters used for this trajectory.

        Returns:
            NumPy array where rows are time points and columns are observable quantities.
        """
        pass
    
    def sample_parameters(self) -> Dict[str, float]:
        """
        Samples random values for the physical parameters within their defined ranges.

        Returns:
            A dictionary of sampled parameter values.
        """
        params = {}
        for param, (low, high) in self.param_ranges.items():
            if low == high: # For fixed parameters
                params[param] = low
            else:
                params[param] = np.random.uniform(low, high)
        return params
        
    def generate_trajectory(self, params: Optional[Dict[str, float]] = None) -> Tuple[np.ndarray, Dict[str, float]]:
        """
        Generates a single trajectory of observables by integrating the system dynamics.

        Args:
            params: Optional dictionary of specific parameters to use for this trajectory.
                    If None, parameters will be sampled.

        Returns:
            A tuple containing:
            - np.ndarray: Observable quantities over time (time_steps, observable_dim).
            - Dict[str, float]: The parameters used for this specific trajectory.
        """
        if params is None:
            params = self.sample_parameters()
        
        # Sample initial conditions for the simulation
        x0 = self.sample_initial_conditions(params)
        
        # Define time points for integration
        t = np.arange(0, self.t_max, self.dt)
        
        # Integrate dynamics using scipy.integrate.odeint
        # The lambda function wraps self.dynamics to pass extra arguments (params)
        solution = integrate.odeint(
            func=lambda state, current_t: self.dynamics(state, current_t, params),
            y0=x0, # Initial state
            t=t # Time points
        )
        
        # Compute observable quantities from the integrated state trajectory
        observables = self.compute_observables(solution, params)
        
        return observables, params # Return both observables and the parameters used
    
    @abstractmethod
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        """
        Samples initial conditions for the system's state variables.
        The `params` argument can be used if initial conditions depend on parameters.

        Returns:
            NumPy array representing the initial state vector.
        """
        pass
    
    def generate_dataset(self, n_samples: int) -> np.ndarray:
        """
        Generates a dataset consisting of multiple trajectories, concatenating
        observable data from each into a single NumPy array.

        Args:
            n_samples: The target number of data points (rows) in the final dataset.
                       Note: this function generates full trajectories and then samples
                       from them, so the actual number of generated data points might
                       be slightly more or less than `n_samples` due to rounding.

        Returns:
            A NumPy array of shape (n_samples, observable_dim), containing aggregated
            data points from various trajectories.
        """
        all_data = []
        
        # Generate enough trajectories to meet or exceed n_samples
        # Assume each trajectory has ~t_max / dt data points.
        # Generate roughly `n_samples / (t_max / dt)` trajectories.
        num_trajectories_to_generate = max(1, int(n_samples / (self.t_max / self.dt) * 2)) # Generate a bit more to ensure enough samples
        
        for _ in range(num_trajectories_to_generate):
            observables, _ = self.generate_trajectory() # Get a trajectory and its params
            
            # Randomly sample points from the generated trajectory
            # This makes the dataset more diverse than just taking full trajectories.
            num_points_to_sample = min(100, len(observables)) # Sample up to 100 points from each trajectory
            if num_points_to_sample > 0:
                indices = np.random.choice(len(observables), size=num_points_to_sample, replace=False)
                all_data.append(observables[indices])
        
        # Concatenate all sampled data points and trim to n_samples if needed
        if not all_data:
            # Handle case where no data was generated (e.g., t_max / dt is very small)
            return np.array([]) # Return empty array if no data
        
        full_dataset = np.vstack(all_data)
        
        # Ensure the final dataset size is exactly n_samples
        if len(full_dataset) > n_samples:
            return full_dataset[np.random.choice(len(full_dataset), n_samples, replace=False)]
        elif len(full_dataset) < n_samples:
            # If not enough unique points, sample with replacement or pad if necessary
            # For simplicity, if not enough, return what we have (can be improved)
            # Or resample with replacement if small_angle is true:
            if len(full_dataset) > 0:
                return full_dataset[np.random.choice(len(full_dataset), n_samples, replace=True)]
            else: # If still empty, return an empty array of correct dimensions.
                # This requires knowing the observable_dim, which is not directly available here.
                # A more robust solution would pass it or infer it.
                return np.array([]) 

        return full_dataset


# --- Concrete Physics Data Generators ---

class HarmonicOscillatorData(PhysicsDataGeneratorBase):
    """
    Data generator for a simple harmonic oscillator.
    State: [position (x), velocity (v)]
    Observables: [x, v, k, m, Energy]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'k': (0.5, 3.0),  # Spring constant
            'm': (0.5, 2.0),  # Mass
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        x, v = state
        k, m = params['k'], params['m']
        return np.array([v, -k/m * x]) # dx/dt = v, dv/dt = -k/m * x
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        x0 = np.random.uniform(-2, 2)
        v0 = np.random.uniform(-2, 2)
        return np.array([x0, v0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [x, v, k, m, E_total]"""
        x, v = trajectory[:, 0], trajectory[:, 1]
        k, m = params['k'], params['m']
        
        E_total = 0.5 * m * v**2 + 0.5 * k * x**2 # Total energy (conserved quantity)
        
        return np.column_stack([
            x, v,
            np.full_like(x, k), # k and m are constants, broadcast to trajectory length
            np.full_like(x, m),
            E_total # Energy as an observable
        ])


class PendulumData(PhysicsDataGeneratorBase):
    """
    Data generator for a simple pendulum.
    State: [angle (theta), angular velocity (omega)]
    Observables: [theta, omega, L, g, angular_accel, (optional) damping_coeff]
    """
    def __init__(self, small_angle: bool = False, **kwargs: Any):
        self.small_angle = small_angle
        super().__init__(**kwargs) # Calls get_default_param_ranges after small_angle is set
    
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        ranges = {
            'L': (0.5, 2.0),  # Length
            'g': (9.81, 9.81),  # Gravity (fixed constant)
        }
        if not self.small_angle: # Only include damping for full nonlinear pendulum
            ranges['b'] = (0.0, 0.5) # Damping coefficient
        return ranges
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        theta, omega = state
        L, g = params['L'], params['g']
        b = params.get('b', 0.0) # Damping coefficient, 0 if not present
        
        if self.small_angle:
            theta_dd = -g/L * theta - b * omega # Linear approximation
        else:
            theta_dd = -g/L * np.sin(theta) - b * omega # Full nonlinear dynamics
        
        return np.array([omega, theta_dd]) # d(theta)/dt = omega, d(omega)/dt = theta_dd
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        if self.small_angle:
            theta0 = np.random.uniform(-0.3, 0.3)  # Small angles for linear approx
        else:
            theta0 = np.random.uniform(-np.pi/2, np.pi/2) # Larger angles for nonlinear
        omega0 = np.random.uniform(-1, 1)
        return np.array([theta0, omega0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [theta, omega, L, g, angular_accel, (optional) b_damping_coeff]"""
        theta, omega = trajectory[:, 0], trajectory[:, 1]
        L, g = params['L'], params['g']
        b = params.get('b', 0.0) # Retrieve damping if exists
        
        if self.small_angle:
            angular_accel = -g/L * theta
        else:
            angular_accel = -g/L * np.sin(theta)
        
        observables_list = [
            theta, 
            omega,
            np.full_like(theta, L),
            np.full_like(theta, g),
            angular_accel
        ]
        if 'b' in params: # Only add if damping is part of this pendulum type
            observables_list.append(np.full_like(theta, b))

        return np.column_stack(observables_list)


class KeplerOrbitData(PhysicsDataGeneratorBase):
    """
    Data generator for orbital mechanics (Kepler orbits).
    Simplification: fixed central mass, single orbiting body.
    State: [x, y, vx, vy] (position and velocity components)
    Observables: [r, v, G, M, F_grav]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'G': (6.67e-11, 6.67e-11),  # Gravitational constant (fixed)
            'M': (5e24, 2e25),          # Central mass (e.g., Earth mass to Neptune mass range)
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        x, y, vx, vy = state
        G, M = params['G'], params['M']
        
        r = np.sqrt(x**2 + y**2)
        # Avoid singularity near the origin
        if r < 1e6: # Use a reasonable small radius limit (e.g., radius of a planet)
            r = 1e6 
        
        # Gravitational acceleration components
        ax = -G * M * x / r**3
        ay = -G * M * y / r**3
        
        return np.array([vx, vy, ax, ay]) # dx/dt, dy/dt, dvx/dt, dvy/dt
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        # Sample initial conditions for a roughly circular orbit
        r0 = np.random.uniform(6.4e6, 4e7) # Example: Near Earth radius to geosynchronous orbit radius
        theta0 = np.random.uniform(0, 2*np.pi) # Random initial angle
        
        x0 = r0 * np.cos(theta0)
        y0 = r0 * np.sin(theta0)
        
        # Calculate initial velocity for a circular orbit at r0
        v_circular = np.sqrt(params['G'] * params['M'] / r0)
        # Velocity components perpendicular to radius vector for circular motion
        vx0 = -v_circular * np.sin(theta0)
        vy0 = v_circular * np.cos(theta0)
        
        # Add small perturbation to make it slightly elliptical (more realistic)
        vx0 *= np.random.uniform(0.9, 1.1)
        vy0 *= np.random.uniform(0.9, 1.1)
        
        return np.array([x0, y0, vx0, vy0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [r, v_magnitude, G, M, F_grav]"""
        x, y, vx, vy = trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], trajectory[:, 3]
        G, M = params['G'], params['M']
        
        r = np.sqrt(x**2 + y**2) # Radial distance
        v_magnitude = np.sqrt(vx**2 + vy**2) # Speed
        F_grav = G * M / r**2 # Gravitational force magnitude
        
        return np.column_stack([
            r, v_magnitude,
            np.full_like(r, G),
            np.full_like(r, M),
            F_grav
        ])


class DampedOscillatorData(PhysicsDataGeneratorBase):
    """
    Data generator for a damped harmonic oscillator.
    State: [position (x), velocity (v)]
    Observables: [x, v, k, m, b, force]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'k': (1.0, 3.0),  # Spring constant
            'm': (0.5, 2.0),  # Mass
            'b': (0.1, 1.0),  # Damping coefficient (must be > 0 for damping)
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        x, v = state
        k, m, b = params['k'], params['m'], params['b']
        return np.array([v, (-k*x - b*v) / m]) # dx/dt = v, dv/dt = (-kx - bv)/m
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        x0 = np.random.uniform(-2, 2)
        v0 = np.random.uniform(-2, 2)
        return np.array([x0, v0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [x, v, k, m, b, force]"""
        x, v = trajectory[:, 0], trajectory[:, 1]
        k, m, b = params['k'], params['m'], params['b']
        
        force = -k*x - b*v # Total force
        
        return np.column_stack([
            x, v,
            np.full_like(x, k),
            np.full_like(x, m), # Added mass to observables
            np.full_like(x, b),
            force
        ])


class IdealGasData(PhysicsDataGeneratorBase):
    """
    Data generator for the ideal gas law, simulating an adiabatic process.
    State: [Pressure (P), Volume (V), Temperature (T)]
    Observables: [P, V, n, T, R_calculated]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'R': (8.314, 8.314),  # Ideal gas constant (fixed)
            'n': (0.1, 2.0),      # Moles of gas
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        P, V, T = state
        n, R = params['n'], params['R']
        gamma = 1.4  # Adiabatic index for diatomic gas (approx air)
        
        # Simulate an oscillating volume change to drive dynamics
        dV_dt = 0.01 * np.cos(t / 2.0) # Varies between -0.01 and 0.01

        # Avoid division by zero if V becomes too small or zero during integration
        if V <= 1e-9: V = 1e-9 
        
        # Adiabatic process equations (P V^gamma = constant)
        dP_dt = -gamma * P / V * dV_dt
        # Ideal gas law: P*V = n*R*T => T = P*V / (n*R)
        # dT_dt = (dP_dt * V + P * dV_dt) / (n * R)
        # Using relation for T from adiabatic process: T V^(gamma-1) = const
        dT_dt = -(gamma - 1) * T / V * dV_dt
        
        return np.array([dP_dt, dV_dt, dT_dt])
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        # Sample valid initial thermodynamic state
        P0 = np.random.uniform(0.5e5, 2e5)  # Pressure: 0.5 to 2 atmospheres in Pascals
        V0 = np.random.uniform(0.01, 0.1)  # Volume: 10 to 100 Liters in m^3
        # Calculate initial temperature using ideal gas law: P0*V0 = n*R*T0
        T0 = P0 * V0 / (params['n'] * params['R'])
        
        return np.array([P0, V0, T0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [P, V, n, T, R_calculated]"""
        P, V, T = trajectory[:, 0], trajectory[:, 1], trajectory[:, 2]
        n, R = params['n'], params['R']
        
        # R_calculated should approximate R (ideal gas constant)
        R_calculated = P * V / (n * T)
        
        return np.column_stack([
            P, V,
            np.full_like(P, n),
            T,
            R_calculated
        ])


class CoulombLawData(PhysicsDataGeneratorBase):
    """
    Data generator for Coulomb's Law, simulating electrostatic interactions.
    Simplification: fixed charge 2 at origin, only charge 1 moves.
    State: [x1, y1, vx1, vy1]
    Observables: [r, q1, q2, k_e, F_coulomb]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'k_e': (8.99e9, 8.99e9),  # Coulomb constant (fixed)
            'q1': (-1e-6, 1e-6),      # Charge 1 (in Coulombs, micro-Coulombs range)
            'q2': (-1e-6, 1e-6),      # Charge 2 (in Coulombs)
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        x, y, vx, vy = state # State of charge 1
        k_e, q1, q2 = params['k_e'], params['q1'], params['q2']
        
        r = np.sqrt(x**2 + y**2)
        if r < 0.01: # Avoid singularity near origin (e.g., minimum separation of 1 cm)
            r = 0.01
        
        # Coulomb force magnitude (F = k_e * |q1*q2| / r^2)
        F_magnitude = k_e * q1 * q2 / r**2 # Force can be attractive or repulsive
        
        # Accelerations (assuming m=1 for the moving charge)
        ax = F_magnitude * x / r # F_x = F * cos(theta) = F * x/r
        ay = F_magnitude * y / r # F_y = F * sin(theta) = F * y/r
        
        return np.array([vx, vy, ax, ay]) # dx/dt, dy/dt, dvx/dt, dvy/dt
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        # Sample initial position for charge 1
        r0 = np.random.uniform(0.1, 1.0) # Initial distance from origin (10cm to 1m)
        theta0 = np.random.uniform(0, 2*np.pi) # Initial angle
        
        x0 = r0 * np.cos(theta0)
        y0 = r0 * np.sin(theta0)
        
        # Sample initial velocity
        v0_magnitude = np.random.uniform(0, 0.5) # Initial speed up to 0.5 m/s
        phi0 = np.random.uniform(0, 2*np.pi) # Direction of initial velocity
        
        vx0 = v0_magnitude * np.cos(phi0)
        vy0 = v0_magnitude * np.sin(phi0)
        
        return np.array([x0, y0, vx0, vy0])
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [r, q1, q2, k_e, F_coulomb]"""
        x, y = trajectory[:, 0], trajectory[:, 1]
        k_e, q1, q2 = params['k_e'], params['q1'], params['q2']
        
        r = np.sqrt(x**2 + y**2)
        F_coulomb = k_e * abs(q1 * q2) / r**2 # Magnitude of Coulomb force
        
        return np.column_stack([
            r,
            np.full_like(r, q1), # q1 and q2 are constants for the trajectory
            np.full_like(r, q2),
            np.full_like(r, k_e),
            F_coulomb
        ])


class ElasticCollisionData(PhysicsDataGeneratorBase):
    """
    Data generator for 1D elastic collisions between two masses.
    Assumes collision happens mid-trajectory and computes post-collision velocities.
    State: [x1, x2, v1, v2] (positions and velocities of two masses)
    Observables: [m1, v1, m2, v2, total_KE, total_momentum]
    """
    def get_default_param_ranges(self) -> Dict[str, Tuple[float, float]]:
        return {
            'm1': (0.5, 2.0), # Mass of object 1
            'm2': (0.5, 2.0), # Mass of object 2
        }
    
    def dynamics(self, state: np.ndarray, t: float, params: Dict[str, float]) -> np.ndarray:
        x1, x2, v1, v2 = state
        # In between collisions, particles move at constant velocity
        return np.array([v1, v2, 0, 0]) # dx1/dt=v1, dx2/dt=v2, dv1/dt=0, dv2/dt=0
    
    def sample_initial_conditions(self, params: Dict[str, float]) -> np.ndarray:
        # Set up a collision scenario: m1 starts left, m2 starts right, moving towards each other
        x1 = np.random.uniform(-2.0, -1.0) # m1 starts at x=-1 to -2
        x2 = np.random.uniform(1.0, 2.0)   # m2 starts at x=1 to 2
        v1 = np.random.uniform(0.5, 2.0)   # m1 moves right
        v2 = np.random.uniform(-2.0, -0.5) # m2 moves left
        return np.array([x1, x2, v1, v2])
    
    def generate_trajectory(self, params: Optional[Dict[str, float]] = None) -> Tuple[np.ndarray, Dict[str, float]]:
        """
        Specialized trajectory generation for collision, handling discrete event.
        """
        if params is None:
            params = self.sample_parameters()
        
        m1, m2 = params['m1'], params['m2']
        
        x0 = self.sample_initial_conditions(params)
        
        t = np.arange(0, self.t_max, self.dt)
        
        # Simulate pre-collision phase
        pre_collision_time = 0.0
        # Find time to collision if they move at constant speeds
        if x0[2] > x0[3]: # If v1 > v2 (they are approaching)
            collision_t = (x0[1] - x0[0]) / (x0[2] - x0[3])
            pre_collision_indices = np.where(t < collision_t)[0]
            pre_collision_time = t[pre_collision_indices[-1]] if pre_collision_indices.size > 0 else 0.0
            
            # Integrate up to collision time
            t_pre = np.arange(0, pre_collision_time + self.dt, self.dt)
            solution_pre = integrate.odeint(
                lambda state, current_t: self.dynamics(state, current_t, params),
                x0, t_pre
            )
            state_at_collision = solution_pre[-1] if solution_pre.size > 0 else x0
            
            # Compute post-collision velocities using elastic collision formulas
            v1_pre, v2_pre = state_at_collision[2], state_at_collision[3]
            v1_post = ((m1 - m2) * v1_pre + 2 * m2 * v2_pre) / (m1 + m2)
            v2_post = ((m2 - m1) * v2_pre + 2 * m1 * v1_pre) / (m1 + m2)
            
            # Simulate post-collision phase
            x_post_initial = np.array([state_at_collision[0], state_at_collision[1], v1_post, v2_post])
            t_post = np.arange(pre_collision_time + self.dt, self.t_max, self.dt)
            solution_post = integrate.odeint(
                lambda state, current_t: self.dynamics(state, current_t, params),
                x_post_initial, t_post
            )
            
            solution = np.vstack([solution_pre, solution_post])
            # Ensure solution has correct length (might be off by 1 due to dt/t_max)
            if len(solution) > len(t): solution = solution[:len(t)]
            elif len(solution) < len(t): # Pad if shorter
                padding = np.full((len(t) - len(solution), solution.shape[1]), np.nan)
                solution = np.vstack([solution, padding])
            
        else: # No collision in this trajectory (or moving away)
            solution = integrate.odeint(
                lambda state, current_t: self.dynamics(state, current_t, params),
                x0, t
            )
        
        observables = self.compute_observables(solution, params)
        return observables, params
    
    def compute_observables(self, trajectory: np.ndarray, params: Dict[str, float]) -> np.ndarray:
        """Return [m1, v1, m2, v2, total_KE, total_momentum] at each step."""
        x1, x2, v1_traj, v2_traj = trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], trajectory[:, 3]
        m1, m2 = params['m1'], params['m2']
        
        # Recalculate KE and momentum for each step
        total_KE = 0.5 * m1 * v1_traj**2 + 0.5 * m2 * v2_traj**2
        total_momentum = m1 * v1_traj + m2 * v2_traj
        
        return np.column_stack([
            np.full_like(v1_traj, m1), # m1 broadcasted to trajectory length
            v1_traj,
            np.full_like(v2_traj, m2), # m2 broadcasted
            v2_traj,
            total_KE,
            total_momentum
        ])


# --- Physics Task Definition and Distribution ---

# (The PhysicsTask and PhysicsTaskDistribution classes will be defined in a separate file,
# as per the updated plan, likely src/janus/physics/data/task_distribution.py)

# For testing this file only, we keep the __main__ block that uses these Data Generators.
if __name__ == "__main__":
    print("--- Testing Physics Data Generators ---")

    # Test Harmonic Oscillator Data
    print("\nHarmonic Oscillator Data:")
    ho_data_gen = HarmonicOscillatorData(t_max=5.0)
    ho_data, ho_params = ho_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {ho_data.shape}")
    print(f"  Parameters: {ho_params}")
    print(f"  Energy (should be constant): {ho_data[:5, -1].round(4)} ... {ho_data[-5:, -1].round(4)}")
    
    ho_dataset = ho_data_gen.generate_dataset(n_samples=500)
    print(f"  Generated dataset shape: {ho_dataset.shape}")
    print(f"  Dataset sample (first 5 rows):\n{ho_dataset[:5].round(4)}")

    # Test Pendulum Data (Small Angle)
    print("\nSmall Angle Pendulum Data:")
    pend_small_data_gen = PendulumData(small_angle=True, t_max=5.0)
    pend_small_data, pend_small_params = pend_small_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {pend_small_data.shape}")
    print(f"  Parameters: {pend_small_params}")

    # Test Pendulum Data (Full Nonlinear)
    print("\nNonlinear Pendulum Data (with damping):")
    pend_full_data_gen = PendulumData(small_angle=False, t_max=10.0, param_ranges={'L': (1.0, 1.0), 'g': (9.81, 9.81), 'b': (0.1, 0.1)})
    pend_full_data, pend_full_params = pend_full_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {pend_full_data.shape}")
    print(f"  Parameters: {pend_full_params}")

    # Test Kepler Orbit Data
    print("\nKepler Orbit Data:")
    kepler_data_gen = KeplerOrbitData(t_max=1000.0, dt=1.0) # Longer simulation, larger dt
    kepler_data, kepler_params = kepler_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {kepler_data.shape}")
    print(f"  Parameters: {kepler_params}")
    print(f"  Force (F_grav) should vary with r: {kepler_data[:5, -1].round(4)}")

    # Test Damped Oscillator Data
    print("\nDamped Oscillator Data:")
    damped_data_gen = DampedOscillatorData(t_max=5.0)
    damped_data, damped_params = damped_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {damped_data.shape}")
    print(f"  Parameters: {damped_params}")
    print(f"  Force should show damping: {damped_data[:5, -1].round(4)}")

    # Test Ideal Gas Data
    print("\nIdeal Gas Data (Adiabatic Process):")
    gas_data_gen = IdealGasData(t_max=5.0)
    gas_data, gas_params = gas_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {gas_data.shape}")
    print(f"  Parameters: {gas_params}")
    print(f"  P*V/(n*T) (should be constant R): {gas_data[:5, -1].round(4)} ... {gas_data[-5:, -1].round(4)}")

    # Test Coulomb Law Data
    print("\nCoulomb Law Data:")
    coulomb_data_gen = CoulombLawData(t_max=1.0, dt=0.001)
    coulomb_data, coulomb_params = coulomb_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {coulomb_data.shape}")
    print(f"  Parameters: {coulomb_params}")
    print(f"  Force (F_coulomb) should vary with r: {coulomb_data[:5, -1].round(4)}")

    # Test Elastic Collision Data
    print("\nElastic Collision Data:")
    collision_data_gen = ElasticCollisionData(t_max=2.0, dt=0.01)
    collision_data, collision_params = collision_data_gen.generate_trajectory()
    print(f"  Single trajectory shape: {collision_data.shape}")
    print(f"  Parameters: {collision_params}")
    # The true_law for ElasticCollision is about conserved KE and momentum, so
    # we expect total_KE and total_momentum columns to be constant through the trajectory.
    print(f"  Total KE (should be constant before/after collision): {collision_data[:5, -2].round(4)} ... {collision_data[-5:, -2].round(4)}")
    print(f"  Total Momentum (should be constant): {collision_data[:5, -1].round(4)} ... {collision_data[-5:, -1].round(4)}")

    print("\nAll Physics Data Generators tested.")

